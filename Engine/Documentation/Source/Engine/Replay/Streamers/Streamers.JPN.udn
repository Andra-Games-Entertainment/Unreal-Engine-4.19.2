INTSourceChangelist:3189265
Availability:Docs
Title:リプレイ システム
Crumbs: %ROOT%, Engine
Description:ゲームプレイを記録し再生するためのリプレイ システムの概要を説明します。
Version:4.14
parent:Engine
order:17
topic-image:replay_topic.png
tags:Replays

[TOC (start:2 end:3)]

## DemoNetDriver 機能
* DemoNetDrivers は、デフォルトで NULL Streamer を使用します。ただし、これは別の Streamer Factory のモジュール名に設定された URL オプション "ReplayStreamerOverride" を受け取ることで、オーバーライドすることができます。例えば、"InMemoryNetworkReplayStreaming" や "HttpNetworkReplayStreaming" などが考えられます。デフォルト値である "NullNetworkReplayStreaming" は、プロジェクトの `DefaultEngine.Ini` ファイルの "NetworkReplayStreaming" セクションにある "DefaultFactoryName" 変数を設定することで変更できます。これは、`InitBase` を呼び出して、適切な URL 引数をパラメータとして指定することでも行うことができます。
* DemoNetDrivers は、リプレイ データを記録する時間の負荷をならすことができます。これを行うには、 "demo.CheckpointSaveMaxMSPerFrame" CVar を正の値に設定します。1 フレームあたりの時間制限になる前にリプレイに記録されないアクタは、記録のために次のフレームにキューします。この機能のメリットは、チェックポイントの記録とテイクの時間の長さに上限を設け、ゲームにヒッチが生じないようにします。欠点は、再生中に若干視覚的エラーが生じることです。これは、チェックポイントに、別のフレームからのアクタのデータが含まれることによって生じます。この機能はチェックポイントを記録するために指定した時間制限よりもゲームが長時間かかる場合に限り有効になります。つまり、主にローエンドのマシンに適用されること、またはパフォーマンス重視のゲームに適用されます。
* `bPrioritizeActors` が true の場合、リプレイに保存されているアクタは記録順の優先度に応じて、`GetReplayPriority` 仮想関数に基づき事前にソートされます。これは `MaxDesiredRecordTimeMS` を介して記録をならす機能と組み合わせると便利です。
* チェックポイントの記録頻度は CVar `demo.CVarCheckpointUploadDelayInSeconds` を変更することで調整することができます。デフォルトは 30 秒です。チェックポイント間の時間の長さを伸ばすと、後方へスクラブまたはリプレイのスキップが遅くなりますが、リプレイのサイズは小さくなります。
* デモを記録中に一時停止するために、変数 `bPauseRecording` を true に設定することができます。false に設定しなおすと記録が再開します。
* **Game Mode** は異なる **Player Controller** クラスを使います。Perspective としての指定は、ユーザー指定の PlayerController によって決まります。
* `SetViewerOverride` を使用し、記録目的で使用される代替の **Player Controller** を作成することで、`DemoNetDriver` がアクタのネットワークの関連性、カリング、および優先順位がどのように決められるかを変更することができます。これは Paragon のような大きなマップがあるゲームで特に役立ちます。プレイヤーはライブ プレイ中に遠くで起こっている物事を必ずしも認識していませんが (効率とチートを防ぐため) 、リプレイを見ると何もかも見えるはずです。
* DemoNetDrivers は Slate と並行して機能することができます。これを行うには "tick.DoAsyncEndOfFrameTasks" と "demo.ClientRecordAsyncEndOfFrame" CVar の両方が非ゼロでなければなりません。

[REGION:note]
リプレイが生成したアクタは、ライブ ゲームプレイのアクタと同様に関数呼び出しをします。これは、最小限のリプレイ データを持つライブ アクタのような挙動をしますが、`GameInstance`、`GameState`、または `GameMode` のような共有オブジェクトに影響を及ぼす関数呼び出しは、なおもリプレイ アクタによって使用可能であり、意図しないやりかたでゲームのステートに影響を及ぼすことも意味します。これは、ライブ ゲームプレイがまだ実行中にリプレイを見ることができる Memory Streamer の場合に特にあてはまります。影響を及ぼすべきではないものに影響を及ぼすアクタから保護するために、まず、アクタがライブまたはリプレイのレベルの一部であるかをチェックし、それに応じたふるまいをするようにします。これはゲーム固有の問題であることが多く、ケースバイケースで各プロジェクトで処理しなければなりません。例えば、あるゲームではリプレイ中にプレイヤーのヘルスバーやフルスクリーンのダメージのオーバーレイを更新するが、プレイヤーのスコアは変更しない場合があるかもしれません。
[/REGION:note]


## NULL Streamer
NULL Streamer はリプレイを記録するデフォルトの方法です。このストリーマーはリプレイ データをローカルのハード ディスクなどのディスクに書き込みます。これは、特にシングル プレイヤーのゲームなどローカルの記録に適した方法です。こうした記録はゲームプレイ トレーラーやインゲームのカットシーンを制作するなど様々な用途で役立ちます。またはゲーム内でスピードランまたはチュートリアルの動画をを見たり共有したりすることができます。


## Memory Streamer
Memory Streamer はローカル マシンのメモリにユーザー設定の長さのリプレイデータ (例、10 秒、3 分など) を保持します。この種のストリームは、最近の劇的瞬間の即時リプレイに最適です。スポーツ ゲームのスコア、シューティング ゲームのデス、アクション ゲームのボス戦の最後の瞬間などが考えられます。

### Memory Streamer 使用の詳細
Memory Streamer は、一回のセッション中にゲームプレイを記録、再生、ゲームプレイを再開するという点で特殊です。プレイヤーがリプレイを見ている間、ライブ ゲームは目に見えないところで、静かに継続します。これはリプレイが終了した瞬間にゲームをシームレスに再開できるようにするためです。ロード時に、エンジンはレベルを以下の 3 つのグループで集めます。すなわち、Static Levels、 Dynamic Source Leves、および Dynamic Duplicated Levels の 3 つです。こうしたグループによって、以下のようにレベルがどのようにライブ ゲームプレイとリプレイ システムとインタラクションするかが決まります。

| レベル コレクション | このコレクションに追加されたレベル | ビヘイビア|
| -------- | ----- | --- |
| Static Levels | パーシスタント レベルではないレベルであり、`IsStatic` boolean のマークが付いているレベルです。 | ゲームプレイの影響はうけません。ライブ プレイとリプレイ中の両方で見えます。 |
| Dynamic Source Levels | パーシスタント レベルと `IsStatic` boolean 変数が false に設定されたサブレベルです。 | ライブ ゲームプレイの影響を受けます。リプレイ中は非表示ですが、ゲームプレイは通常どおり実行しています。 |
| Dynamic Duplicate Levels | ロード時に Dynamic Source Level から作られたコピーです。専用サーバーまたはエディタ モードでは存在しません。 | ライブ ゲームプレイ中には非表示になります。リプレイはこうしたレベルで行われた後、空になります。 |

[Is Static] 設定は、Window メニューから Levels ビューを起動すると表示されます。サブレベルをハイライトした状態で [Level Details (レベルの詳細)] ボタンをクリックします。

![](Sublevel.png)

そこから、 [Level Details] ウィンドウで [Is Static] オプションを利用することができます。このウィンドウは パーシスタント レベルでは空であるため、必ずサブ レベルを選択するようにしてください。

![](IsStatic.png)

[REGION:note]
レベル コレクションは、レベル ストリーミング プロセスの一部であり、リプレイ システムには特に関連はありません。
[/REGION:note]

こうしたシステムでは、Dynamic Source Level に対してひとつの `DemoNetDriver` を作成し、Dynamic Duplicate Level に対してもうひとつ `DemoNetDriver` を作成することができます。その結果、Dynamic Source Level でライブ ゲームプレイを記録して、Dynamic Duplicate Level でそれを再生することができます。Dynamic Source Level を隠して、リプレイ中に Dynamic Duplicated Level を表示することで、ゲームはプレイを継続し、リプレイによる影響を受けないネットワークの更新を受け取ることができます。3 つめのグループである Static Level はいつでもアクティブで可視状態になります。ライブ ゲームプレイの影響を受けない静的なワールド ジオメトリや環境音、パーティクル、アニメーションのようなものを含みます。従ってリプレイ プロセスに含む必要はありません。リプレイが終了すると、Dynamic Duplicate Level のコンテンツは破棄され、ガーベジ コレクションの対象になり、Dynamic Source Level は再び可視 / 可聴になります。Dynamic Source Level は決して破棄されたり、一時停止せず、非表示であるだけなので、リプレイを見ている間、ゲームは自然に進捗し、ただちに処理落ちなしで表示可能です。さらにこのシステムでは、レベルに static とマーク付けする機能があり、リプレイの記録と再生から除外することができます。その結果、メモリと時間を節約することができます。

<!--
これは、記録と再生のアクティビティを別個のレベル、および別個の `DemoNetDriver` で行うことで実現できます。このシステムの効率を高めるために、アンリアル エンジンはレベルを以下の 3 つのコレクションに分けます。Static、Dynamic Source、および Dynamic Duplicated の 3 つです。Static レベルはいつでもアクティブで可視状態になります。ライブ ゲームプレイの影響を受けない静的なワールド ジオメトリや環境音、パーティクル、アニメーションを含みます。従って複製、記録、再生の必要はありません。ライブ ゲームは Dynamic Source レベルでプレイされます。これには、ゲームプレイの影響を受けるアクタが含まれます。例えば、プレイヤーがコントロールするキャラクター、敵、ボーナス ピックアップ、開閉するドアなどがあります。ライブ ゲームプレイはこうしたレベルで起こるため、これらはリプレイの記録に使用され、再生中には非表示になります。再生は Dynamic Duplicated レベルで行われます。これは、Source Dynamic レベルの空のコピーを作ることで作成されます。これらは再生でのみ使用されるため、ゲームの実際のプレイ中は空で非表示になります。リプレイ中にアクタによって埋められ、リプレイが終了すると空になります (リプレイで生成されたアクタは破棄されガーベジ コレクションの対象になります)。
-->


## HTTP Streamer
HTTP Streamer はリプレイ データを、LAN 上またはインターネット上のどこかにある別のサーバーに送信します。これはライブ ストリーミングの対戦で役立ちます。またはいつでも見ることができる対戦の記録を維持するために役立ちます。このストリーマーは、専用サーバーだけがいつでもゲーム内で起こっていることをすべて把握している場合に、専用サーバーのゲームで特に役立ちます。リプレイ データを処理する作業から解放すると、単一サーバーで同時にホスト可能なゲーム数が増えます。モデレーションやチート検出ツールとしても機能します。ゲームを実行する当事者によって完全に制御されるコンピュータからデータをキャプチャーできるからです。
