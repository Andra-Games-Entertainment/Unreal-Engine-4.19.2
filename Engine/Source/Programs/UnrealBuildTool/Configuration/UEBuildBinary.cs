// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml;
using System.Globalization;

namespace UnrealBuildTool
{
	/// <summary>
	/// All binary types generated by UBT
	/// </summary>
	public enum UEBuildBinaryType
	{
		/// <summary>
		/// An executable
		/// </summary>
		Executable,

		/// <summary>
		/// A dynamic library (.dll, .dylib, or .so)
		/// </summary>
		DynamicLinkLibrary,

		/// <summary>
		/// A static library (.lib or .a)
		/// </summary>
		StaticLibrary,

		/// <summary>
		/// An object file (.obj or .o)
		/// </summary>
		Object,

		/// <summary>
		/// A precompiled header (.pch or .gch)
		/// </summary>
		PrecompiledHeader
	}

	/// <summary>
	/// UEBuildBinary configuration
	/// Configuration class for a UEBuildBinary.
	/// Exposes the configuration values of the BuildBinary class without exposing the functions.
	/// </summary>
	public class UEBuildBinaryConfiguration
	{
		/// <summary>
		/// The type of binary to build
		/// </summary>
		public UEBuildBinaryType Type;

		/// <summary>
		/// The output file path. This must be set before a binary can be built using it.
		/// </summary>
		public List<FileReference> OutputFilePaths = new List<FileReference>();

		/// <summary>
		/// Returns the OutputFilePath if there is only one entry in OutputFilePaths
		/// </summary>
		public FileReference OutputFilePath
		{
			get
			{
				if (OutputFilePaths.Count != 1)
				{
					throw new BuildException("Attempted to use UEBuildBinaryConfiguration.OutputFilePath property, but there are multiple (or no) OutputFilePaths. You need to handle multiple in the code that called this (size = {0})", OutputFilePaths.Count);
				}
				return OutputFilePaths[0];
			}
		}

		/// <summary>
		/// Original output filepath. This is the original binary name before hot-reload suffix has been appended to it.
		/// </summary>
		public List<FileReference> OriginalOutputFilePaths;

		/// <summary>
		/// Returns the OriginalOutputFilePath if there is only one entry in OriginalOutputFilePaths
		/// </summary>
		public FileReference OriginalOutputFilePath
		{
			get
			{
				if (OriginalOutputFilePaths.Count != 1)
				{
					throw new BuildException("Attempted to use UEBuildBinaryConfiguration.OriginalOutputFilePath property, but there are multiple (or no) OriginalOutputFilePaths. You need to handle multiple in the code that called this (size = {0})", OriginalOutputFilePaths.Count);
				}
				return OriginalOutputFilePaths[0];
			}
		}

		/// <summary>
		/// The intermediate directory for this binary. Modules should create separate intermediate directories below this. Must be set before a binary can be built using it.
		/// </summary>
		public DirectoryReference IntermediateDirectory;

		/// <summary>
		/// If true, build exports lib
		/// </summary>
		public bool bAllowExports = false;

		/// <summary>
		/// If true, create a separate import library
		/// </summary>
		public bool bCreateImportLibrarySeparately = false;

		/// <summary>
		/// If true, include dependent libraries in the static library being built
		/// </summary>
		public bool bIncludeDependentLibrariesInLibrary = false;

		/// <summary>
		/// If false, this binary will not be compiled and it is only used to set up link environments
		/// </summary>
		public bool bAllowCompilation = true;

		/// <summary>
		/// True if this binary has any Build.cs files, if not this is probably a binary-only plugins
		/// </summary>
		public bool bHasModuleRules = true;

		/// <summary>
		/// For most binaries, this is false. If this is a cross-platform binary build for a specific platform (for example XB1 DLL for a windows editor) this will be true.
		/// </summary>
		public bool bIsCrossTarget = false;

		/// <summary>
		/// This binary is only being created because UBT is being run with the -precompile option; it is not linked into the target.
		/// </summary>
		public bool bPrecompileOnly = false;

		/// <summary>
		/// If true, creates an additional console application. Hack for Windows, where it's not possible to conditionally inherit a parent's console Window depending on how
		/// the application is invoked; you have to link the same executable with a different subsystem setting.
		/// </summary>
		public bool bBuildAdditionalConsoleApp = false;

		/// <summary>
		/// The projectfile path
		/// </summary>
		public FileReference ProjectFilePath;

		/// <summary>
		/// List of modules to link together into this executable
		/// </summary>
		public List<string> ModuleNames = new List<string>();

		/// <summary>
		/// The configuration class for a binary build.
		/// </summary>
		/// <param name="InType"></param>
		/// <param name="InOutputFilePaths"></param>
		/// <param name="InIntermediateDirectory"></param>
		/// <param name="bInAllowExports"></param>
		/// <param name="bInCreateImportLibrarySeparately"></param>
		/// <param name="bInIncludeDependentLibrariesInLibrary"></param>
		/// <param name="bInAllowCompilation"></param>
		/// <param name="bInHasModuleRules"></param>
		/// <param name="bInIsCrossTarget">For most binaries, this is false. If this is a cross-platform binary build for a specific platform (for example XB1 DLL for a windows editor) this will be true.</param>
		/// <param name="bInPrecompileOnly"></param>
		/// <param name="InProjectFilePath"></param>
		/// <param name="InModuleNames"></param>
		public UEBuildBinaryConfiguration(
				UEBuildBinaryType InType,
				IEnumerable<FileReference> InOutputFilePaths = null,
				DirectoryReference InIntermediateDirectory = null,
				bool bInAllowExports = false,
				bool bInCreateImportLibrarySeparately = false,
				bool bInIncludeDependentLibrariesInLibrary = false,
				bool bInAllowCompilation = true,
				bool bInHasModuleRules = true,
				bool bInIsCrossTarget = false,
				bool bInPrecompileOnly = false,
				FileReference InProjectFilePath = null,
				IEnumerable<string> InModuleNames = null
			)
		{
			Type = InType;
			if (InOutputFilePaths != null)
			{
				OutputFilePaths.AddRange(InOutputFilePaths);
			}
			IntermediateDirectory = InIntermediateDirectory;
			bAllowExports = bInAllowExports;
			bCreateImportLibrarySeparately = bInCreateImportLibrarySeparately;
			bIncludeDependentLibrariesInLibrary = bInIncludeDependentLibrariesInLibrary;
			bAllowCompilation = bInAllowCompilation;
			bHasModuleRules = bInHasModuleRules;
			bIsCrossTarget = bInIsCrossTarget;
			bPrecompileOnly = bInPrecompileOnly;
			ProjectFilePath = InProjectFilePath;
			if (InModuleNames != null)
			{
				ModuleNames.AddRange(InModuleNames);
			}
		}
	}


	/// <summary>
	/// A binary built by UBT.
	/// </summary>
	abstract class UEBuildBinary
	{
		/// <summary>
		/// The build binary configuration data
		/// </summary>
		public UEBuildBinaryConfiguration Config;

		/// <summary>
		/// Create an instance of the class with the given configuration data
		/// </summary>
		/// <param name="InConfig">The build binary configuration to initialize the class with</param>
		public UEBuildBinary(UEBuildBinaryConfiguration InConfig)
		{
			Debug.Assert(InConfig.OutputFilePath != null && InConfig.IntermediateDirectory != null);
			Config = InConfig;
		}

		/// <summary>
		/// Creates all the modules referenced by this target.
		/// </summary>
		public virtual void CreateAllDependentModules(UEBuildModule.CreateModuleDelegate CreateModule) { }

		/// <summary>
		/// Builds the binary.
		/// </summary>
		/// <param name="Target">Rules for the target being built</param>
		/// <param name="ToolChain">The toolchain which to use for building</param>
		/// <param name="CompileEnvironment">The environment to compile the binary in</param>
		/// <param name="LinkEnvironment">The environment to link the binary in</param>
		/// <param name="SharedPCHs">List of templates for shared PCHs</param>
		/// <param name="ActionGraph">Graph to add build actions to</param>
		/// <returns>Set of built products</returns>
		public abstract IEnumerable<FileItem> Build(ReadOnlyTargetRules Target, UEToolChain ToolChain, CppCompileEnvironment CompileEnvironment, LinkEnvironment LinkEnvironment, List<PrecompiledHeaderTemplate> SharedPCHs, ActionGraph ActionGraph);

		/// <summary>
		/// Called to allow the binary to modify the link environment of a different binary containing 
		/// a module that depends on a module in this binary. */
		/// </summary>
		/// <param name="DependentLinkEnvironment">The link environment of the dependency</param>
		public virtual void SetupDependentLinkEnvironment(LinkEnvironment DependentLinkEnvironment) { }

		/// <summary>
		/// Called to allow the binary to to determine if it matches the Only module "short module name".
		/// </summary>
		/// <param name="OnlyModules"></param>
		/// <returns>The OnlyModule if found, null if not</returns>
		public virtual OnlyModule FindOnlyModule(List<OnlyModule> OnlyModules)
		{
			return null;
		}

		/// <summary>
		/// Called to allow the binary to find game modules.
		/// </summary>
		/// <returns>The OnlyModule if found, null if not</returns>
		public virtual List<UEBuildModule> FindGameModules()
		{
			return null;
		}

		/// <summary>
		/// Generates a list of all modules referenced by this binary
		/// </summary>
		/// <param name="bIncludeDynamicallyLoaded">True if dynamically loaded modules (and all of their dependent modules) should be included.</param>
		/// <param name="bForceCircular">True if circular dependencies should be process</param>
		/// <returns>List of all referenced modules</returns>
		public virtual List<UEBuildModule> GetAllDependencyModules(bool bIncludeDynamicallyLoaded, bool bForceCircular)
		{
			return new List<UEBuildModule>();
		}

		public virtual void FindModuleReferences(Dictionary<UEBuildModule, UEBuildModule> ReferencedBy)
		{
		}

		/// <summary>
		/// Sets whether to create a separate import library to resolve circular dependencies for this binary
		/// </summary>
		/// <param name="bInCreateImportLibrarySeparately">True to create a separate import library</param>
		public virtual void SetCreateImportLibrarySeparately(bool bInCreateImportLibrarySeparately)
		{
		}

		/// <summary>
		/// Sets whether to include dependent libraries when building a static library
		/// </summary>
		/// <param name="bInIncludeDependentLibrariesInLibrary">True to include dependent libraries</param>
		public virtual void SetIncludeDependentLibrariesInLibrary(bool bInIncludeDependentLibrariesInLibrary)
		{
		}

		/// <summary>
		/// Adds a module to the binary.
		/// </summary>
		/// <param name="Module">The module to add</param>
		public virtual void AddModule(UEBuildModule Module)
		{
		}

		/// <summary>
		/// Gets all build products produced by this binary
		/// </summary>
		/// <param name="Target">The target being built</param>
		/// <param name="ToolChain">The platform toolchain</param>
		/// <param name="BuildProducts">Mapping of produced build product to type</param>
		/// <param name="bCreateDebugInfo">Whether debug info is enabled for this binary</param>
		public void GetBuildProducts(ReadOnlyTargetRules Target, UEToolChain ToolChain, Dictionary<FileReference, BuildProductType> BuildProducts, bool bCreateDebugInfo)
		{
			// Get the type of build products we're creating
			BuildProductType Type = BuildProductType.RequiredResource;
			switch (Config.Type)
			{
				case UEBuildBinaryType.Executable:
					Type = BuildProductType.Executable;
					break;
				case UEBuildBinaryType.DynamicLinkLibrary:
					Type = BuildProductType.DynamicLibrary;
					break;
				case UEBuildBinaryType.StaticLibrary:
					Type = BuildProductType.StaticLibrary;
					break;
			}

			// Add the primary build products
			string DebugExtension = UEBuildPlatform.GetBuildPlatform(Target.Platform).GetDebugInfoExtension(Target, Config.Type);
			foreach (FileReference OutputFilePath in Config.OutputFilePaths)
			{
				AddBuildProductAndDebugFile(OutputFilePath, Type, DebugExtension, BuildProducts, ToolChain, bCreateDebugInfo);
			}

			// Add the console app, if there is one
			if (Config.Type == UEBuildBinaryType.Executable && Config.bBuildAdditionalConsoleApp)
			{
				foreach (FileReference OutputFilePath in Config.OutputFilePaths)
				{
					AddBuildProductAndDebugFile(GetAdditionalConsoleAppPath(OutputFilePath), Type, DebugExtension, BuildProducts, ToolChain, bCreateDebugInfo);
				}
			}

			// Add any additional build products from the modules in this binary, including additional bundle resources/dylibs on Mac.
			List<string> Libraries = new List<string>();
			List<UEBuildBundleResource> BundleResources = new List<UEBuildBundleResource>();
			GatherAdditionalResources(Libraries, BundleResources);

			// Add any extra files from the toolchain
			ToolChain.ModifyBuildProducts(Target, this, Libraries, BundleResources, BuildProducts);
		}

		/// <summary>
		/// Adds a build product and its associated debug file to a receipt.
		/// </summary>
		/// <param name="OutputFile">Build product to add</param>
		/// <param name="OutputType">The type of built product</param>
		/// <param name="DebugExtension">Extension for the matching debug file (may be null).</param>
		/// <param name="BuildProducts">Map of build products to their type</param>
		/// <param name="ToolChain">The toolchain used to build these binaries</param>
		/// <param name="bCreateDebugInfo">Whether creating debug info is enabled</param>
		static void AddBuildProductAndDebugFile(FileReference OutputFile, BuildProductType OutputType, string DebugExtension, Dictionary<FileReference, BuildProductType> BuildProducts, UEToolChain ToolChain, bool bCreateDebugInfo)
		{
			BuildProducts.Add(OutputFile, OutputType);

			if (!String.IsNullOrEmpty(DebugExtension) && ToolChain.ShouldAddDebugFileToReceipt(OutputFile, OutputType) && bCreateDebugInfo)
			{
				BuildProducts.Add(OutputFile.ChangeExtension(DebugExtension), BuildProductType.SymbolFile);
			}
		}

		/// <summary>
		/// Enumerates resources which the toolchain may need may produced additional build products from. Some platforms (eg. Mac, Linux) can link directly 
		/// against .so/.dylibs, but they are also copied to the output folder by the toolchain.
		/// </summary>
		/// <param name="Libraries">List to which libraries required by this module are added</param>
		/// <param name="BundleResources">List of bundle resources required by this module</param>
		public virtual void GatherAdditionalResources(List<string> Libraries, List<UEBuildBundleResource> BundleResources)
		{
		}

		/// <summary>
		/// Helper function to get the console app BinaryName-Cmd.exe filename based on the binary filename.
		/// </summary>
		/// <param name="BinaryPath">Full path to the binary exe.</param>
		/// <returns></returns>
		public static FileReference GetAdditionalConsoleAppPath(FileReference BinaryPath)
		{
			return FileReference.Combine(BinaryPath.Directory, BinaryPath.GetFileNameWithoutExtension() + "-Cmd" + BinaryPath.GetExtension());
		}

		/// <summary>
		/// Checks whether the binary output paths are appropriate for the distribution
		/// level of its direct module dependencies
		/// </summary>
		public bool CheckRestrictedFolders(DirectoryReference ProjectDir, Dictionary<UEBuildModule, Dictionary<RestrictedFolder, DirectoryReference>> ModuleRestrictedFolderCache)
		{
			// Find all the modules we depend on
			Dictionary<UEBuildModule, UEBuildModule> ModuleReferencedBy = new Dictionary<UEBuildModule, UEBuildModule>();
			FindModuleReferences(ModuleReferencedBy);

			// Loop through each of the output binaries and check them separately
			bool bResult = true;
			foreach (FileReference OutputFilePath in Config.OutputFilePaths)
			{
				// Find the base directory for this binary
				DirectoryReference BaseDir;
				if(OutputFilePath.IsUnderDirectory(UnrealBuildTool.EngineDirectory))
				{
					BaseDir = UnrealBuildTool.EngineDirectory;
				}
				else if(ProjectDir != null && OutputFilePath.IsUnderDirectory(ProjectDir))
				{
					BaseDir = ProjectDir;
				}
				else
				{
					continue;
				}

				// Find the restricted folders under the base directory
				List<RestrictedFolder> BinaryFolders = RestrictedFolders.FindRestrictedFolders(BaseDir, OutputFilePath.Directory);

				// Check all the dependent modules
				foreach(UEBuildModule Module in ModuleReferencedBy.Keys)
				{
					// Find the restricted folders for this module
					Dictionary<RestrictedFolder, DirectoryReference> ModuleRestrictedFolders;
					if (!ModuleRestrictedFolderCache.TryGetValue(Module, out ModuleRestrictedFolders))
					{
						ModuleRestrictedFolders = Module.FindRestrictedFolderReferences(ProjectDir);
						ModuleRestrictedFolderCache.Add(Module, ModuleRestrictedFolders);
					}

					// Write errors for any missing paths in the output files
					foreach(KeyValuePair<RestrictedFolder, DirectoryReference> Pair in ModuleRestrictedFolders)
					{
						if(!BinaryFolders.Contains(Pair.Key))
						{
							List<string> ReferenceChain = new List<string>();
							for(UEBuildModule ReferencedModule = Module; ReferencedModule != null; ReferencedModule = ModuleReferencedBy[ReferencedModule])
							{
								ReferenceChain.Insert(0, ReferencedModule.Name);
							}
							Log.TraceError("ERROR: Output binary \"{0}\" is not in a {1} folder, but references \"{2}\" via {3}.", OutputFilePath, Pair.Key.ToString(), Pair.Value, String.Join(" -> ", ReferenceChain));
							bResult = false;
						}
					}
				}
			}
			return bResult;
		}

		/// <summary>
		/// Write information about this binary to a JSON file
		/// </summary>
		/// <param name="Writer">Writer for this binary's data</param>
		public virtual void ExportJson(JsonWriter Writer)
		{
			Writer.WriteValue("File", Config.OutputFilePath.FullName);
			Writer.WriteValue("Type", Config.Type.ToString());

			Writer.WriteArrayStart("Modules");
			foreach(string ModuleName in Config.ModuleNames)
			{
				Writer.WriteValue(ModuleName);
			}
			Writer.WriteArrayEnd();
		}
	}
}
