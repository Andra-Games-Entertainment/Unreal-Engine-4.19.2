// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Common.usf"

/*=============================================================================
	MonteCarlo.usf: Monte Carlo integration of distributions
=============================================================================*/

float3x3 GetTangentBasis( float3 TangentZ )
{
	float3 UpVector = abs(TangentZ.z) < 0.999 ? float3(0,0,1) : float3(1,0,0);
	float3 TangentX = normalize( cross( UpVector, TangentZ ) );
	float3 TangentY = cross( TangentZ, TangentX );
	return float3x3( TangentX, TangentY, TangentZ );
}

float3 TangentToWorld( float3 Vec, float3 TangentZ )
{
	return mul( Vec, GetTangentBasis( TangentZ ) );
}

float2 Hammersley( uint Index, uint NumSamples, uint2 Random )
{
	float E1 = frac( (float)Index / NumSamples + float( Random.x & 0xffff ) / (1<<16) );
	float E2 = float( ReverseBits32(Index) ^ Random.y ) * 2.3283064365386963e-10;
	return float2( E1, E2 );
}

///////
// Typical usage of the Sobol functions below:
//   1: uint4 base = PixelSobol(uint2(SvPosition.xy), View.FrameNumber); // Sample 0 at pixel current frame
//   2: uint4 rand = base;
//   3: float2 point0 = float2(rand.xy) / 0x1000000; // 2D point from first independent 2D sample set, in [0,1) x [0,1)
//   4: float2 point1 = float2(rand.zw) / 0x1000000; // 2D point from second 2D sample set, in [0,1) x [0,1)
//      ...
//   5: rand = DirectSobol(base, 1);                 // Sample 1 for current pixel/frame
//      ...
//   6: rand = DirectSobol(base, 2);                 // Sample 2 for current pixel/frame (up to sample 1023)
// Equivalent and possibly slightly faster
//   1-4: As above
//   5: rand = NextSobol(rand, 1);
//      ...
//   6: rand = NextSobol(rand, 2);
// If index is not constant (or in an unrolled loop), can use Bits argument to DirectSobol
//   for(int i=1; i<7; ++i)
//      rand = DirectSobol(base, i, 3);  // since i <= 3 bits
//
// Frame is just the bottom three bits of a global index. If changing per frame isn't needed, use
//   PixelSobol(uint2(SvPosition.xy), Index); // for Index in [0,7]
//   DirectSobol(PixelSobol(..., Index & 7), Index >> 3) // for Index in [0, 8191]
//
// In all cases, if more than two 2D streams are needed, xor base with a random 24-bit-per-component uint2 seed

// Evaluate initial Sobol points for a pixel
// @param PixelPos Screen position
// @param Frame    Current frame number or frame mod 8 (only uses bottom 3 bits)
// @return four 16-bit Sobol numbers in the range 0 to 0xffff
uint4 PixelSobol(uint2 PixelPos, uint Frame)
{
	// look up for pixel
	int3 SobolCoord = int3(PixelPos, 0) & 0xff;
	uint4 Result = View.SobolSamplingTexture.Load(SobolCoord);

	// factor in frame number
	Result ^= (Frame & 1) ? uint4(0xfb00u, 0xc700u, 0x8680u, 0x4c80u) : 0;
	Result ^= (Frame & 2) ? uint4(0x50c0u, 0x9740u, 0xf240u, 0x9240u) : 0;
	Result ^= (Frame & 4) ? uint4(0x06e0u, 0x8fa0u, 0x8220u, 0x0e20u) : 0;
	return Result;
}

// Evaluate Sobol sequence directly from sequence index
// @param Base  Base Sobol values for this pixel
// @param Index Which 4D Sobol point to return
// @param Bits  Optional max bits in index (to avoid extra calculation)
// @return four 16-bit Sobol numbers in the range 0 to 0xffff
uint4 DirectSobol(uint4 Base, int Index, int Bits = 10)
{
	uint4 SobolNumbers[10] = {
		uint4(0x2c10u, 0xfab0u, 0x4110u, 0x1610u),
		uint4(0xe868u, 0x0a08u, 0xa608u, 0x7608u),
		uint4(0x880eu, 0x821eu, 0x8a02u, 0x280au),
		uint4(0x0c5cu, 0x9e54u, 0xe204u, 0x9e04u),
		uint4(0xe945u, 0xf8edu, 0xa400u, 0x4682u),
		uint4(0x8068u, 0x0f80u, 0xe300u, 0xa74du),
		uint4(0x660eu, 0x8580u, 0xb700u, 0x9817u),
		uint4(0x905cu, 0x9000u, 0x4501u, 0x1405u),
		uint4(0xbc45u, 0xf380u, 0x0c00u, 0x5826u),
		uint4(0x00e8u, 0x0780u, 0x2600u, 0x760bu),
	};

	uint4 Result = Base;
	UNROLL for (int b = 0; b < 10 && b < Bits; ++b)
	{
		Result ^= (Index & (1 << b)) ? SobolNumbers[b] : 0;
	}
	return Result;
}

// Evaluate Sobol sequence sequentially from previous value and index
// @param Previous Sobol values for index-1
// @param Index    Which 4D Sobol point to return. Must be in the range 1 to 1023
// @return four 16-bit Sobol numbers in the range 0 to 0xffff
// matches DirectSobol, but more efficient when computing sequential values
uint4 NextSobol(uint4 Previous, int Index)
{
	// SobolGray[i] is SobolNumbers[0] ^ SobolNumbers[1] ^ ... ^ SobolNumbers[i]
	uint4 SobolGray[10] = {
		uint4(0x2c10u, 0xfab0u, 0x4110u, 0x1610u),
		uint4(0xc478u, 0xf0b8u, 0xe718u, 0x6018u),
		uint4(0x4c76u, 0x72a6u, 0x6d1au, 0x4812u),
		uint4(0x402au, 0xecf2u, 0x8f1eu, 0xd616u),
		uint4(0xa96fu, 0x141fu, 0x2b1eu, 0x9094u),
		uint4(0x2907u, 0x1b9fu, 0xc81eu, 0x37d9u),
		uint4(0x4f09u, 0x9e1fu, 0x7f1eu, 0xafceu),
		uint4(0xdf55u, 0x0e1fu, 0x3a1fu, 0xbbcbu),
		uint4(0x6310u, 0xfd9fu, 0x361fu, 0xe3edu),
		uint4(0x63f8u, 0xfa1fu, 0x101fu, 0x95e6u)
	};

	return Previous ^ SobolGray[firstbitlow(Index)];
}

///////
float4 UniformSampleSphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = 1 - 2 * E.y;
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float PDF = 1.0 / (4 * PI);

	return float4( H, PDF );
}

float4 UniformSampleHemisphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = E.y;
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float PDF = 1.0 / (2 * PI);

	return float4( H, PDF );
}

float2 UniformSampleDisk(float2 Random)
{
	const float Theta = 2.0f * (float)PI * Random.x;
	const float Radius = sqrt(Random.y);
	return float2(Radius * cos(Theta), Radius * sin(Theta));
}

float4 CosineSampleHemisphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = sqrt( E.y );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float PDF = CosTheta / PI;

	return float4( H, PDF );
}

float4 UniformSampleCone( float2 E, float CosThetaMax )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = lerp( CosThetaMax, 1, E.y );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 L;
	L.x = SinTheta * cos( Phi );
	L.y = SinTheta * sin( Phi );
	L.z = CosTheta;

	float PDF = 1.0 / ( 2 * PI * (1 - CosThetaMax) );

	return float4( L, PDF );
}

float4 ImportanceSampleBlinn( float2 E, float Roughness )
{
	float m = Roughness * Roughness;
	float n = 2 / (m*m) - 2;

	float Phi = 2 * PI * E.x;
	float CosTheta = ClampedPow( E.y, 1 / (n + 1) );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float D = (n+2)/ (2*PI) * ClampedPow( CosTheta, n );
	float PDF = D * CosTheta;

	return float4( H, PDF );
}

float4 ImportanceSampleGGX( float2 E, float Roughness )
{
	float m = Roughness * Roughness;
	float m2 = m * m;

	float Phi = 2 * PI * E.x;
	float CosTheta = sqrt( (1 - E.y) / ( 1 + (m2 - 1) * E.y ) );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;
	
	float d = ( CosTheta * m2 - CosTheta ) * CosTheta + 1;
	float D = m2 / ( PI*d*d );
	float PDF = D * CosTheta;

	return float4( H, PDF );
}

// Multiple importance sampling power heuristic of two functions with a power of two. 
// [Veach 1997, "Robust Monte Carlo Methods for Light Transport Simulation"]
float MISWeight( uint Num, float PDF, uint OtherNum, float OtherPDF )
{
	float Weight = Num * PDF;
	float OtherWeight = OtherNum * OtherPDF;
	return Weight * Weight / (Weight * Weight + OtherWeight * OtherWeight);
}